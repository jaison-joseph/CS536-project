
- prerequisites
	- python3 (I used 3.10.2
	- networkx install on python3

- Just run:
`python3 master.py <number of nodes> [nsfnet/geant2/germany50] <number of simulation runs> <time per simulation in SECONDS> <frequency of statistics in MILLISECONDS> <traffic intensity>`
	- the second argment: nsfnet/geant2/germany50 is the type of network, each one more densely connected than the other (nsfnet least, germany50 most
		- I have only used nsfnet so far, the others I'm not sure of it.
	- the master.py orchestrates all the terminals to run the simulation

- Here is the overview of what master.py does:
	- starts by generating the files for each simulation
		- custom_topo.py
			- used by mininet to construct the network
		- get_hops.sh
			- script to use in ONOS container to get the hops between each source/destination pair; its results are used to generate the port matrix
				- the output of this is `paths.txt`, in each simulation dir
		- onos_config.json
			- for ONOS to construct connections to the switches in the network
		- test.py
			- the file that collects the metrics
			- uses d-itg
		- topo.json
			- our network representation file, used internally

	- the files are generated by `main.py` and `main_extension.py`
		- `main.py` generates everything except the test script `test.py`

	- look at the function `run_setup` in `master.py` to get the idea of what happens for a round of a simulation
	- the function `runner` does set up for a simulation

	- please note that the file "test.py" changes between runs: specifically the locations where the output raw filed and decoded files change

	- the output should look like:
	```
	simulations/
		<network_type>_<# nodes>_<traffic intensity>/
			run_1/
				raw_data/
					2024-11-29-19:10:46.121925_4_4_0_1 
					2024-11-29-19:10:46.121925_4_4_0_2 
					2024-11-29-19:10:46.121925_4_4_0_3
					...
				decoded_data/
					2024-11-29-19:10:46.121925_4_4_0_1 
					2024-11-29-19:10:46.121925_4_4_0_2 
					2024-11-29-19:10:46.121925_4_4_0_3
					...
			run_2/
				...
	```